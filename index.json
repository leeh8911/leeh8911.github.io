[{"categories":["TIL"],"content":"Always I am improving developer!","date":"2022-06-06","objectID":"/220606/","tags":["git","change_commit_date","sstream","iomanip","pad_digit","sysconf"],"title":"220606","uri":"/220606/"},{"categories":["TIL"],"content":"Git ","date":"2022-06-06","objectID":"/220606/:0:0","tags":["git","change_commit_date","sstream","iomanip","pad_digit","sysconf"],"title":"220606","uri":"/220606/"},{"categories":["TIL"],"content":"Git commit 날짜 바꾸기 git commit --amend --no-edit --date \"DD MM YYYY hh:mm:ss\" 특정 커밋에 대해 --amend는 이전 커밋 내용에 덮어쓰기의 의미 --no-edit은 현재 커밋 내용을 수정사항 없이 반영하겠다는 의미 --date는 날짜에 대한 옵션 Udacity ","date":"2022-06-06","objectID":"/220606/:1:0","tags":["git","change_commit_date","sstream","iomanip","pad_digit","sysconf"],"title":"220606","uri":"/220606/"},{"categories":["TIL"],"content":"ElapsedTime (seconds data convert HH:MM:SS) \u003ciomanip\u003e헤더 파일의 std::setfill('0')를 이용해 공백 자리를 0으로 채워넣고, std::setw(2)로 폭을 2로 설정해 놓음 \u003csstream\u003e 헤더 파일의 std::stringstream을 이용해 문자열의 처리를 \u003c\u003c 연산으로 해결 #include \u003csstream\u003e#include \u003ciomanip\u003e#include \u003cstring\u003e std::string foo(int32_t seconds){ int32_t second = seconds % 60; seconds /= 60; int32_t minute = seconds % 60; int32_t hour = seconds / 60; stringstream ss(\"\"); ss \u003c\u003c std::setfill('0') \u003c\u003c std::setw(2) \u003c\u003c hour \u003c\u003c \":\" \u003c\u003c minute \u003c\u003c \":\" \u003c\u003c second; return ss.str(); } ","date":"2022-06-06","objectID":"/220606/:2:0","tags":["git","change_commit_date","sstream","iomanip","pad_digit","sysconf"],"title":"220606","uri":"/220606/"},{"categories":["TIL"],"content":"sysconf sysconf 런타임에 대한 설정 정보 획득 reference sysconf(_SC_CLK_TCK) : 초당 클락(clock) 틱 수 정보를 얻음 ","date":"2022-06-06","objectID":"/220606/:3:0","tags":["git","change_commit_date","sstream","iomanip","pad_digit","sysconf"],"title":"220606","uri":"/220606/"},{"categories":["TIL"],"content":"istringstream.good good 스트림의 상태가 좋은지 확인 std::ios::good ","date":"2022-06-06","objectID":"/220606/:4:0","tags":["git","change_commit_date","sstream","iomanip","pad_digit","sysconf"],"title":"220606","uri":"/220606/"},{"categories":["TIL"],"content":"Always I am improving developer!","date":"2022-06-05","objectID":"/220605/","tags":["memory_utilization"],"title":"220605","uri":"/220605/"},{"categories":["TIL"],"content":"Udacity ","date":"2022-06-05","objectID":"/220605/:0:0","tags":["memory_utilization"],"title":"220605","uri":"/220605/"},{"categories":["TIL"],"content":"Memory Utilization Reference /proc 은 가상의 파일 시스템 /proc/meminfo는 비어있거나 사용중인 메모리의 양을 보고하기 위한 곳 cat /proc/meminfo를 통해 획득한 정보들은 상위와 하위 통계 형태로 제공 Stack-over-flow (mem usage from meminfo like htop) memory utilization은 MemTotal에서 MemFree + MemBuffers + Shmem + SReclaimable 의 총 합을 뺀 것(?) ","date":"2022-06-05","objectID":"/220605/:1:0","tags":["memory_utilization"],"title":"220605","uri":"/220605/"},{"categories":["TIL"],"content":"Always I am improving developer!","date":"2022-06-04","objectID":"/220604/","tags":["linux_system_data","process_data","processor_data","system_data"],"title":"220604","uri":"/220604/"},{"categories":["TIL"],"content":"System Data ","date":"2022-06-04","objectID":"/220604/:1:0","tags":["linux_system_data","process_data","processor_data","system_data"],"title":"220604","uri":"/220604/"},{"categories":["TIL"],"content":"Processor Data ","date":"2022-06-04","objectID":"/220604/:2:0","tags":["linux_system_data","process_data","processor_data","system_data"],"title":"220604","uri":"/220604/"},{"categories":["TIL"],"content":"Process Data Udacity ","date":"2022-06-04","objectID":"/220604/:3:0","tags":["linux_system_data","process_data","processor_data","system_data"],"title":"220604","uri":"/220604/"},{"categories":["TIL"],"content":"System Data Linux 수 많은 시스템 데이터를 /proc 디렉터리에 파일로 저장해두고 있음 Operating System : cat /etc/os-release Kernel : cat /proc/version Memory Utilization : cat /proc/meminfo Total Processes : cat /proc/stat Up Time : cat /proc/uptime ","date":"2022-06-04","objectID":"/220604/:4:0","tags":["linux_system_data","process_data","processor_data","system_data"],"title":"220604","uri":"/220604/"},{"categories":["TIL"],"content":"Processor Data Linux 는 프로세서 데이터를 proc/stat에 있는 파일에 저장 각 cpu에는 10개의 정수형 정보가 포함되어 있음 cpu0 6367 4 2360 4403129 9065 0 3972 0 0 0 first cpu는 각 cpuN의 총합이고 그 외 나머지는 각각의 cpu 소요 시간에 대한 정보 시간의 단위는 USER_HZ (보통은 hundredths of a second) 각 열의 의미는 아래와 같다(행의 왼쪽부터 오른쪽) user: normal processes executing in user mode nice: niced processes executing in user mode system: processes executing in kernel mode idle: twiddling thumbs iowait: In a word, iowait stands for waiting for I/O to complete. But there are several problems: Cpu will not wait for I/O to complete, iowait is the time that a task is waiting for I/O to complete. When cpu goes into idle state for outstanding task io, another task will be scheduled on this CPU. In a multi-core CPU, the task waiting for I/O to complete is not running on any CPU, so the iowait of each CPU is difficult to calculate. The value of iowait field in /proc/stat will decrease in certain conditions. So, the iowait is not reliable by reading from /proc/stat. irq: servicing interrupts softirq: servicing softirqs steal: involuntary wait guest: running a normal guest guest_nice: running a niced guest references : Guide, Stack-over-flow ","date":"2022-06-04","objectID":"/220604/:5:0","tags":["linux_system_data","process_data","processor_data","system_data"],"title":"220604","uri":"/220604/"},{"categories":["TIL"],"content":"Process Data PID (Process Identifier) UID (User Identifier) Username Processor Utilization Memory Utilization Up Time ","date":"2022-06-04","objectID":"/220604/:6:0","tags":["linux_system_data","process_data","processor_data","system_data"],"title":"220604","uri":"/220604/"},{"categories":[],"content":"Always I am improving developer!","date":"2022-06-03","objectID":"/220603/","tags":["deduction"],"title":"220603","uri":"/220603/"},{"categories":[],"content":"Deduction ","date":"2022-06-03","objectID":"/220603/:1:0","tags":["deduction"],"title":"220603","uri":"/220603/"},{"categories":[],"content":"Exercise Class Template ","date":"2022-06-03","objectID":"/220603/:2:0","tags":["deduction"],"title":"220603","uri":"/220603/"},{"categories":[],"content":"System Monitor Project! ","date":"2022-06-03","objectID":"/220603/:3:0","tags":["deduction"],"title":"220603","uri":"/220603/"},{"categories":[],"content":"Style Code (C++) #Udacity ","date":"2022-06-03","objectID":"/220603/:4:0","tags":["deduction"],"title":"220603","uri":"/220603/"},{"categories":[],"content":"Deduction deduction Deduction은 객체를 생성할 때 타입을 명시하지 않으면 발생 예제 코드 #include \u003cassert.h\u003e // TODO: Declare a generic, templatized average function template\u003ctypename T\u003e T average(T a, T b) {return (a + b) * 0.5; } int main() { assert(average(2.0,5.0) == 3.5); } ","date":"2022-06-03","objectID":"/220603/:5:0","tags":["deduction"],"title":"220603","uri":"/220603/"},{"categories":[],"content":"Exercise Class Template #include \u003cassert.h\u003e#include \u003cstring\u003e#include \u003csstream\u003e // TODO: Add the correct template specification template\u003ctypename KeyType, typename ValueType\u003e class Mapping { public: Mapping(KeyType key, ValueType value) : key(key), value(value) {} std::string Print() const { std::ostringstream stream; stream \u003c\u003c key \u003c\u003c \": \" \u003c\u003c value; return stream.str(); } KeyType key; ValueType value; }; // Test int main() { Mapping\u003cstd::string, int\u003e mapping(\"age\", 20); assert(mapping.Print() == \"age: 20\"); } ","date":"2022-06-03","objectID":"/220603/:6:0","tags":["deduction"],"title":"220603","uri":"/220603/"},{"categories":[],"content":"System Monitor Project! htop - Linux system monitor ","date":"2022-06-03","objectID":"/220603/:7:0","tags":["deduction"],"title":"220603","uri":"/220603/"},{"categories":[],"content":"Style Code (C++) clang-format ","date":"2022-06-03","objectID":"/220603/:8:0","tags":["deduction"],"title":"220603","uri":"/220603/"},{"categories":["TIL"],"content":"Always I am improving developer!","date":"2022-06-02","objectID":"/220602/","tags":["multiple_inheritance","generic_programming","template"],"title":"220602","uri":"/220602/"},{"categories":["TIL"],"content":"Generic Programming ","date":"2022-06-02","objectID":"/220602/:1:0","tags":["multiple_inheritance","generic_programming","template"],"title":"220602","uri":"/220602/"},{"categories":["TIL"],"content":"Multiple Inheritance Udacity ","date":"2022-06-02","objectID":"/220602/:2:0","tags":["multiple_inheritance","generic_programming","template"],"title":"220602","uri":"/220602/"},{"categories":["TIL"],"content":"Multiple Inheritance “Use multiple inheritance to represent multiple distinct interfaces” “Use multiple inheritance to represent the union of implementation attributes” Diamond Problem : 하나의 클래스가 두개의 base class로 부터 상속받고, 이 두개의 base class들은 동일한 추상 클래스로부터 상속을 받았다면, 충돌이 생긴다. e.g. class Vehicle { public: virtual string Move() const = 0; }; class Boat : public Vehicle{ string Move() const; }; class Car : public Vehicle { string Move() const; }; class AmphibiousCar : public Boat, public Car{ }; int main(){ AmphibiousCar ab_car; ab_car.move(); // Which is inherited? return 0; } ","date":"2022-06-02","objectID":"/220602/:3:0","tags":["multiple_inheritance","generic_programming","template"],"title":"220602","uri":"/220602/"},{"categories":["TIL"],"content":"Generic Programming template을 사용하여 다양한 타입에 대응할 수 있도록 만드는 것을 generic programming 대표적으로 STL의 vector ","date":"2022-06-02","objectID":"/220602/:4:0","tags":["multiple_inheritance","generic_programming","template"],"title":"220602","uri":"/220602/"},{"categories":["TIL"],"content":"Template template 은 타입을 파라미터처럼 사용하여 다양한 데이터 타입에 대한 연산을 하나로 구현할 수 있음 template \u003ctypename Type\u003e Type Sum(Type a, Type b) {return a + b;} 실습 #include \u003cassert.h\u003e // TODO: Create a generic function Product that multiplies two parameters template\u003ctypename T\u003e T Product(T a, T b) {return a * b;} int main() { assert(Product\u003cint\u003e(10, 2) == 20); } 예제 : 비교 연산자 #include \u003cassert.h\u003e // TODO: Declare a generic, templatized function Max() template\u003ctypename T\u003e T Max(T a, T b) {return a \u003e b ? a : b;} int main() { assert(Max(10, 50) == 50); assert(Max(5.7, 1.436246) == 5.7); } ","date":"2022-06-02","objectID":"/220602/:4:1","tags":["multiple_inheritance","generic_programming","template"],"title":"220602","uri":"/220602/"},{"categories":["TIL"],"content":"Always I am improving developer!","date":"2022-06-01","objectID":"/220601/","tags":["operator_overloading","virtual_function","overriding","udacity"],"title":"220601","uri":"/220601/"},{"categories":["TIL"],"content":"Polymorphism: overloading (review) ","date":"2022-06-01","objectID":"/220601/:1:0","tags":["operator_overloading","virtual_function","overriding","udacity"],"title":"220601","uri":"/220601/"},{"categories":["TIL"],"content":"Polymorphism: operator ","date":"2022-06-01","objectID":"/220601/:2:0","tags":["operator_overloading","virtual_function","overriding","udacity"],"title":"220601","uri":"/220601/"},{"categories":["TIL"],"content":"Virtual Functions ","date":"2022-06-01","objectID":"/220601/:3:0","tags":["operator_overloading","virtual_function","overriding","udacity"],"title":"220601","uri":"/220601/"},{"categories":["TIL"],"content":"Overriding ","date":"2022-06-01","objectID":"/220601/:4:0","tags":["operator_overloading","virtual_function","overriding","udacity"],"title":"220601","uri":"/220601/"},{"categories":["TIL"],"content":"Polymorphism: operator ","date":"2022-06-01","objectID":"/220601/:5:0","tags":["operator_overloading","virtual_function","overriding","udacity"],"title":"220601","uri":"/220601/"},{"categories":["TIL"],"content":"Virtual Functions ","date":"2022-06-01","objectID":"/220601/:6:0","tags":["operator_overloading","virtual_function","overriding","udacity"],"title":"220601","uri":"/220601/"},{"categories":["TIL"],"content":"Overriding ","date":"2022-06-01","objectID":"/220601/:7:0","tags":["operator_overloading","virtual_function","overriding","udacity"],"title":"220601","uri":"/220601/"},{"categories":["TIL"],"content":"Polymorphism: overloading (review) 이전 강의에서 마저 듣지 못했던 나머지 내용 (코드 실습) #include \u003ciostream\u003e class Human {}; class Animal {}; class Dog {}; // TODO: Write hello() function void hello() { std::cout \u003c\u003c \"Hello, World!\\n\"; } // TODO: Overload hello() three times void hello(Human human) { std::cout \u003c\u003c \"Hello, Human!\\n\"; } void hello(Animal animal) { std::cout \u003c\u003c \"Hello, Animal!\\n\"; } void hello(Dog dog) { std::cout \u003c\u003c \"Hello, Dog!\\n\"; } // TODO: Call hello() from main() int main() { hello(); hello(Human()); hello(Animal()); hello(Dog()); } ","date":"2022-06-01","objectID":"/220601/:8:0","tags":["operator_overloading","virtual_function","overriding","udacity"],"title":"220601","uri":"/220601/"},{"categories":["TIL"],"content":"Polymorphism: operator ASCII table에 정의된 연산자를 선택해 새로운 연산 집합의 규칙을 정할 수 있음 // Example of '*'(plus) operator overloading! Complex operator+(const Complex\u0026 addend) { //...logic to add complex numbers } operator overloading, \u003c+,-,/,*\u003e + \u003c++, –, +=, -=, *=, /=\u003e, \u003c==, \u003c,\u003e,\u003c=,\u003e=,!=\u003e, … 등등 실습 코드 #include \u003cassert.h\u003e class Point { public: Point(int x, int y) : x(x), y(y){} int x; int y; Point operator+(const Point\u0026 p2){ return Point(x+p2.x, y+p2.y);} }; int main() { Point p1(10, 5), p2(2, 4); Point p3 = p1 + p2; // An example call to \"operator +\"; assert(p3.x == p1.x + p2.x); assert(p3.y == p1.y + p2.y); } ","date":"2022-06-01","objectID":"/220601/:9:0","tags":["operator_overloading","virtual_function","overriding","udacity"],"title":"220601","uri":"/220601/"},{"categories":["TIL"],"content":"Virtual Functions virtual return_t foo(input_t vars); virtual function은 다형성을 위한 특징 virtual function은 인터페이스를 위해 사용됨 pure virtual function virtual return_t foo(input_t vars); = 0 class Animal { virtual void Talk() const = 0; }; virtual function이 있는 클래스를 상속 받으면 해당 virtual function을 구현해야 함 virtual function이 있는 클래스는 인스턴스를 만들 수 없음 실습 코드 // Example solution for Shape inheritance #include \u003cassert.h\u003e#include \u003ccmath\u003e // TODO: Define pi const double pi = 3.14159; // TODO: Define the abstract class Shape class Shape{ // TODO: Define public virtual functions Area() and Perimeter() // TODO: Append the declarations with = 0 to specify pure virtual functions public: virtual double Area(void) const = 0; virtual double Perimeter(void) const = 0; }; class Rectangle : public Shape{ public: Rectangle(int width, int height) : width(width), height(height) {}; double Area(void) const { return width * height; } double Perimeter(void) const { return 2 * (width + height); } private: int width; int height; }; class Circle : public Shape { public: Circle(int radius) : radius(radius) {}; double Area(void) const { return radius * radius * pi; } double Perimeter(void) const { return 2 * pi * radius; } private: int radius; }; // Test in main() int main() { double epsilon = 0.1; // useful for floating point equality // Test circle Circle circle(12.31); assert(abs(circle.Perimeter() - 77.35) \u003c epsilon); assert(abs(circle.Area() - 476.06) \u003c epsilon); // Test rectangle Rectangle rectangle(10, 6); assert(rectangle.Perimeter() == 32); assert(rectangle.Area() == 60); } ","date":"2022-06-01","objectID":"/220601/:10:0","tags":["operator_overloading","virtual_function","overriding","udacity"],"title":"220601","uri":"/220601/"},{"categories":["TIL"],"content":"Overriding ","date":"2022-06-01","objectID":"/220601/:11:0","tags":["operator_overloading","virtual_function","overriding","udacity"],"title":"220601","uri":"/220601/"},{"categories":["TIL"],"content":"Concept of overriding overriding은 base class가 virtual함수로 정의 되었을 때 발생 derived class가 virtual 함수가 갖고 있던 입/출력 파라미터로 정의 예시 class Animal { public: virtual std::striing Talk() const = 0; }; class Cat{ public: std::string Talk() const { return std::string(\"Meow\"); } }; 실습 #include \u003cassert.h\u003e#include \u003cstring\u003e class Animal { public: virtual std::string Talk() const = 0; }; // TODO: Declare a class Dog that inherits from Animal class Dog { public: std::string Talk() { return \"Woof\"; } }; int main() { Dog dog; assert(dog.Talk() == \"Woof\"); } ","date":"2022-06-01","objectID":"/220601/:11:1","tags":["operator_overloading","virtual_function","overriding","udacity"],"title":"220601","uri":"/220601/"},{"categories":["TIL"],"content":"Function hiding function hiding 은 overriding과 유사하지만, 구분되는 특징이 있음 base class의 함수가 virtual로 정의 되지 않는다면 derived class 는 base class 의 함수를 숨김(hide) 예시 class Cat { // Here, Cat does not derive from a base class public: std::string Talk() const { return std::string(\"Meow\"); } }; class Lion : public Cat { public: std::string Talk() const { return std::string(\"Roar\"); } }; ","date":"2022-06-01","objectID":"/220601/:11:2","tags":["operator_overloading","virtual_function","overriding","udacity"],"title":"220601","uri":"/220601/"},{"categories":["TIL"],"content":"Override keyword overriding은 derived class가 상속 받은 virtual함수를 구현하였을 때 발생 override 키워드를 통해 지정할 수 있지만, 필수적이진 않음 이 키워드를 사용할 때, overriding 되지 않으면 에러가 발생함 예시 코드 class Shape { public: virtual double Area() const = 0; virtual double Perimeter() const = 0; }; class Circle : public Shape { public: Circle(double radius) : radius_(radius) {} double Area() const override { return pow(radius_, 2) * PI; } // specified as an override function double Perimeter() const override { return 2 * radius_ * PI; } // specified as an override function private: double radius_; }; 실습 코드 #include \u003cassert.h\u003e#include \u003ccmath\u003e // TODO: Define PI const double PI = 3.14159; // TODO: Declare abstract class VehicleModel class VehicleModel { // TODO: Declare virtual function Move() public: virtual void Move(double v, double theta) = 0; }; // TODO: Derive class ParticleModel from VehicleModel class ParticleModel : public VehicleModel { // TODO: Override the Move() function // TODO: Define x, y, and theta public: void Move(double v, double phi) { theta += phi; x += v * cos(theta); y += v * sin(theta); } double x, y, theta; }; // TODO: Derive class BicycleModel from ParticleModel class BicycleModel : public ParticleModel { public: void Move(double v, double phi) { theta += v / L * tan(phi); x += v * cos(theta); y += v * sin(theta); } double L; }; // TODO: Pass the tests int main() { // Test function overriding ParticleModel particle; BicycleModel bicycle; particle.Move(10, PI / 9); bicycle.Move(10, PI / 9); assert(particle.x != bicycle.x); assert(particle.y != bicycle.y); assert(particle.theta != bicycle.theta); } ","date":"2022-06-01","objectID":"/220601/:11:3","tags":["operator_overloading","virtual_function","overriding","udacity"],"title":"220601","uri":"/220601/"},{"categories":["TIL"],"content":"Always I am improving developer!","date":"2022-05-31","objectID":"/220531/","tags":["friend","polymorphism","overloading","udacity"],"title":"220531","uri":"/220531/"},{"categories":["TIL"],"content":"Polymorphism 다형성(polymorphism)은 “수 많은 형태를 가정\"했다는 의미 ","date":"2022-05-31","objectID":"/220531/:1:0","tags":["friend","polymorphism","overloading","udacity"],"title":"220531","uri":"/220531/"},{"categories":["TIL"],"content":"Friend friend 클래스는 상속의 대안 ","date":"2022-05-31","objectID":"/220531/:2:0","tags":["friend","polymorphism","overloading","udacity"],"title":"220531","uri":"/220531/"},{"categories":["TIL"],"content":"Friend friend 클래스는 상속의 대안 일반적인 상속과 달리 private 멤버에도 접근 가능 class Heart { private: int rate{80}; friend class Human; } class Human { public: Heart heart; void Exercise(){ heart.rate = 150;} void HeartRate(){return heart.rate;} }; ","date":"2022-05-31","objectID":"/220531/:3:0","tags":["friend","polymorphism","overloading","udacity"],"title":"220531","uri":"/220531/"},{"categories":["TIL"],"content":"Polymorphism 다형성(polymorphism)은 “수 많은 형태를 가정\"했다는 의미 다형성은 C++상에서 두가지 방법으로 구현: overloading \u0026 overriding Overloading 두가지 이상의 이름만 같고 다른 버전의 함수를 구현하는 것을 일컫음 이름만 같고 입력 인수는 다양한 함수들! ","date":"2022-05-31","objectID":"/220531/:4:0","tags":["friend","polymorphism","overloading","udacity"],"title":"220531","uri":"/220531/"},{"categories":["TIL"],"content":"Always I am improving developer!","date":"2022-05-30","objectID":"/220530/","tags":["inheritance","access-specifier","composition","udacity"],"title":"220530","uri":"/220530/"},{"categories":["TIL"],"content":"Inheritance “Is a” ","date":"2022-05-30","objectID":"/220530/:1:0","tags":["inheritance","access-specifier","composition","udacity"],"title":"220530","uri":"/220530/"},{"categories":["TIL"],"content":"Access specifier 상속 받을 때 접근자를 통해 상위 객체의 멤버 변수나 멤버 메소드에 접근을 제한할 수 있음 ","date":"2022-05-30","objectID":"/220530/:2:0","tags":["inheritance","access-specifier","composition","udacity"],"title":"220530","uri":"/220530/"},{"categories":["TIL"],"content":"Composition “Has a” ","date":"2022-05-30","objectID":"/220530/:3:0","tags":["inheritance","access-specifier","composition","udacity"],"title":"220530","uri":"/220530/"},{"categories":["TIL"],"content":"Inheritance “Is a” 객체 지향의 토대가 되는 상속(inheritance) 상위 객체의 메소드와 변수 등을 상속 받은 하위 객체가 사용 가능 하위 객체는 상위 객체에 없는 메소드와 변수 등을 추가로 정의해 좀 더 구체적인 구현체를 만들 수 있음 상위 객체는 하위 객체들을 추상화 한 구현체 접근자(access specifier)를 통해 멤버 변수나 멤버 메소드에 접근을 제한하여 캡슐화(encapsulation) ","date":"2022-05-30","objectID":"/220530/:4:0","tags":["inheritance","access-specifier","composition","udacity"],"title":"220530","uri":"/220530/"},{"categories":["TIL"],"content":"Access specifier 상속 받을 때 접근자를 통해 상위 객체의 멤버 변수나 멤버 메소드에 접근을 제한할 수 있음 Public: 상속 받은 상위 객체의 public or protected 멤버 변수 및 멤버 메소드에 하위 객체가 접근 가능 Protect: 상속 받은 상위 객체의 public or protected 멤버 변수 및 멤버 메소드에 하위 객체의 protected 멤버로 접근자가 정해짐 Private: 상속 받은 상위 객체의 public or protected 멤버 변수 및 멤버 메소드에 하위 객체의 private 멤버로 접근자가 정해짐 ","date":"2022-05-30","objectID":"/220530/:5:0","tags":["inheritance","access-specifier","composition","udacity"],"title":"220530","uri":"/220530/"},{"categories":["TIL"],"content":"Composition “Has a” 상속을 받는 것이 아닌 다른 객체를 멤버로 받아 오는 것 ","date":"2022-05-30","objectID":"/220530/:6:0","tags":["inheritance","access-specifier","composition","udacity"],"title":"220530","uri":"/220530/"}]