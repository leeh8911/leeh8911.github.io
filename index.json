[{"categories":["TIL"],"content":"Always I am improving developer!","date":"2022-06-27","objectID":"/220627/","tags":[],"title":"220627","uri":"/220627/"},{"categories":["TIL"],"content":" Resource Acquisition is Initialization 자원의 획득과 해제: 신뢰할 수 있는 자원 해제 문제 RAII to the rescue What is RAII Udacity ","date":"2022-06-27","objectID":"/220627/:0:0","tags":[],"title":"220627","uri":"/220627/"},{"categories":["TIL"],"content":"Resource Acquisition is Initialization 자원의 획득과 해제: new or malloc을 통한 메모리 할당을 하면, delete or free를 매치시켜줘야 함 파일이나 네트워크를 연결하였다면, 필요없어진 시점에 닫아야 함 동시성 보호를 위한 atomic operations, memory barriers, monitors, critical sections를 할당했다면, 다른 쓰레드에서 그것들을 가져가기 전에 해제해줘야 함 신뢰할 수 있는 자원 해제 문제 일반적인 패턴: [자원 획득] -\u003e [자원 사용] -\u003e [자원 해제] 일반적인 패턴의 문제: 프로그램은 리소스 사용 중 예외를 throw할 수 있어 release지점에 도달하지 못할 수도 있음 해제될 수 있는 시점이 많아 프로그래머가 모든 상황을 추적할 수 없음 다시 해제하는 것을 잃어 버릴 수도 있음 RAII to the rescue RAII의 주된 아이디어는 객체 소유권과 정보 은닉에 관한 것 클래스 관리에 할당과 해제를 숨겨 놓았기 때문에 개발자는 걱정할 필요가 없음 직접 할당하지 않았다면, 직접 해제해줄 필요 없음 RAII는 클래스를 관리하며 자원을 보호해줌 new and delete와 같은 할당/해제를 코드의 표면에서 숨길 수 있음 장점: 클래스의 소멸자를 사용하여 RAII 객체가 범위를 벗어날 때, 적절한 메모리 할당/해제와 같은 리소스 정리작업 수행 동적으로 할당된 객체의 소유권 및 수명 관리 동일한 객체 내에서 수행되는 리소스 획득 및 해제로 인한 캡슐화 및 정보 은닉 구현 메모리 관리 관점에서의 RAII RAII 클래스의 생성자로 자원 할당 RAII 클래스의 소멸자로 자원 해제 RAII 클래스의 모든 인스턴스는 스택에 할당되어 개체 범위를 통해 수명을 안정적으로 제어 Others ","date":"2022-06-27","objectID":"/220627/:1:0","tags":[],"title":"220627","uri":"/220627/"},{"categories":["TIL"],"content":"What is RAII blog C++에서 자주 쓰이는 idiom으로 자원의 안전한 사용을 위해 객체가 쓰이는 스코프를 벗어나면, 자원을 해제해주는 기법 ","date":"2022-06-27","objectID":"/220627/:2:0","tags":[],"title":"220627","uri":"/220627/"},{"categories":["TIL"],"content":"Always I am improving developer!","date":"2022-06-26","objectID":"/220626/","tags":["rule_of_three","new","delete","memory_ownership","smart_pointer"],"title":"220626","uri":"/220626/"},{"categories":["TIL"],"content":" Move semantic Rule of Tree: 메모리 관리를 위해 필요한 것 before C++11 SMART POINTER Resource Acquisition is initialization new와 delete에 대한 문제점들 스마트 포인터의 이점 Udacity ","date":"2022-06-26","objectID":"/220626/:0:0","tags":["rule_of_three","new","delete","memory_ownership","smart_pointer"],"title":"220626","uri":"/220626/"},{"categories":["TIL"],"content":"Move semantic Rule of Tree: 메모리 관리를 위해 필요한 것 Overloaded copy constructor Copy assignment operator Destructor before C++11 SMART POINTER ","date":"2022-06-26","objectID":"/220626/:1:0","tags":["rule_of_three","new","delete","memory_ownership","smart_pointer"],"title":"220626","uri":"/220626/"},{"categories":["TIL"],"content":"Resource Acquisition is initialization new와 delete에 대한 문제점들 적절한 페어링이 필요 : new로 생성된 변수들은 적절한 시점에 delete해야 함. 그렇지 않으면 메모리 누수가 발생 올바른 연산 페어링 : new로 생성되면 delete으로, new[]로 생성되었으면 delete[]로 삭제 해야함. 그렇지 않으면 프로그램이 정의되지 않은 행동을 하게 됨 메모리의 소유권 : 리소스 할당/해제를 누가 담당하는지 알아야 함. 그렇지 않으면 잘못된 소유권을 갖고 있는 메모리를 해제함으로써 내부 작동에 방해가 됨 스마트 포인터의 이점: 스마트 포인터는 C++에서 소개된 것으로 자동으로 메모리 관리를 도와줌 (더 이상 필요 없어진 포인터는 자동으로 해제 됨) 스마트 포인터는 원본 포인터를 감싼 클래스로 -\u003e와 *연산을 overload 함 RAII (Resource Acquisition Is Initialization, 자원 획득 시 초기화) ","date":"2022-06-26","objectID":"/220626/:2:0","tags":["rule_of_three","new","delete","memory_ownership","smart_pointer"],"title":"220626","uri":"/220626/"},{"categories":["TIL"],"content":"Always I am improving developer!","date":"2022-06-24","objectID":"/220624/","tags":["copy","deep_copy","shallow_copy","shared_copy","lvalue","rvalue"],"title":"220624","uri":"/220624/"},{"categories":["TIL"],"content":" Copy Semantics Exclusive copy class Deep copy class Shared copy class L-values and R-values Udacity ","date":"2022-06-24","objectID":"/220624/:0:0","tags":["copy","deep_copy","shallow_copy","shared_copy","lvalue","rvalue"],"title":"220624","uri":"/220624/"},{"categories":["TIL"],"content":"Copy Semantics Exclusive copy class class ExclusiveCopy { private: int* _myInt; public: ExclusiveCopy() { _myInt = (int*)malloc(sizeof(int)); } ~ExclusiveCopy() { if (_myInt != nullptr) { free(_myInt); } } ExclusiveCopy(ExclusiveCopy\u0026 source) { _myInt = source._myInt; source._myInt = nullptr; } ExclusiveCopy\u0026 operator=(ExclusiveCopy\u0026 source) { _myInt = source._myInt; source._myInt = nullptr; return *this; } }; 복사 생성이나 할당 연산 수행시 멤버 변수 중 포인터 변수의 소유권도 같이 넘겨줌 (같은 포인터를 여러 객체가 소유하게 되면, 누가 언제 해제하게 될지 알 수 없어 위험함) Deep copy class class DeepCopy { private: int *_myInt; public: DeepCopy() { _myInt = (int*)malloc(sizeof(int)); } ~DeepCopy() { if (_myInt != nullptr) { free(_myInt); } DeepCopy(DeepCopy\u0026 source) { _myInt = (int*)malloc(sizeof(int)); *_myInt = *source._myInt; } DeepCopy\u0026 operator=(DeepCopy\u0026 source) { _myInt = (int*)malloc(sizeof(int)); *_myInt = *source._myInt; return *this; } }; 깊은 복사는 단순 주소값만 가져오는 것이 아니라, 값을 복사해옴 하지만 메모리 요구량이 증가하고, 데이터의 유일성은 잃어버리게 됨 Shared copy class { private: int *_myInt; static int _cnt; public: SharedCopy(int val); ~SharedCopy(); SharedCopy(SharedCopy \u0026source); }; int SharedCopy::_cnt = 0; SharedCopy::SharedCopy(int val) { _myInt = (int *)malloc(sizeof(int)); *_myInt = val; ++_cnt; std::cout \u003c\u003c \"resource allocated at address \" \u003c\u003c _myInt \u003c\u003c std::endl; } SharedCopy::~SharedCopy() { --_cnt; if (_cnt == 0) { free(_myInt); std::cout \u003c\u003c \"resource freed at address \" \u003c\u003c _myInt \u003c\u003c std::endl; } else { std::cout \u003c\u003c \"instance at address \" \u003c\u003c this \u003c\u003c \" goes out of scope with _cnt = \" \u003c\u003c _cnt \u003c\u003c std::endl; } } SharedCopy::SharedCopy(SharedCopy \u0026source) { _myInt = source._myInt; ++_cnt; std::cout \u003c\u003c _cnt \u003c\u003c \" instances with handles to address \" \u003c\u003c _myInt \u003c\u003c \" with _myInt = \" \u003c\u003c *_myInt \u003c\u003c std::endl; } 얕은 복사와 유사하지만, 몇 번 복사가 되었는지 확인 추후 알아보게 될 unique_ptr의 아이디어 ","date":"2022-06-24","objectID":"/220624/:1:0","tags":["copy","deep_copy","shallow_copy","shared_copy","lvalue","rvalue"],"title":"220624","uri":"/220624/"},{"categories":["TIL"],"content":"L-values and R-values C+11부터 하나의 표현식은 5가지의 값을 갖음 Expression | +- glvalue | +- lvalue | | | +-xvalue | | +- rvalue +- prvalue Lvalues: 접근 가능한 주소를 갖고 있음 컴파일러의 평가에 따라 함수 또는 객체의 ID가 결정되는 식 Prvalues: 직접 접근이 가능한 주소를 갖고 있지 않음 임시적인 표현식으로 객체의 초기화나 어떤 값에 대한 연산을 수행할 때 피연사자로 사용됨 단순함을 위해 Udacity 강좌에선 Prvalues를 rvalue라고 표현함 int i = 42; // lvalue = rvalue; lvalue references lvalue reference는 개체의 대체 이름으로 간주됨 int i = 1, \u0026j = i; 라고 적으면, j는 i의 또 다른 이름 rvalue references rvalue의 경우 lvalue reference에 대입하면 컴파일 오류가 발생함 void myFunction(int \u0026val) { std::cout \u003c\u003c \"val = \" \u003c\u003c val \u003c\u003c std::endl; } int main() { int j = 42; myFunction(j); myFunction(42); int k = 23; myFunction(j+k); return 0; } * C++11부터는 rvalue reference라는 새로운 타입이 생김! (`\u0026\u0026`를 씀으로써 가능해짐) * 위의 코드에서 `int \u0026val --\u003e int \u0026\u0026val`로 바꾼다면 오히려 사용 가능했던 `j`에 대한 함수에서 에러가 발생하고, 나머지 두개에 대해서는 정상적으로 실행됨 ","date":"2022-06-24","objectID":"/220624/:2:0","tags":["copy","deep_copy","shallow_copy","shared_copy","lvalue","rvalue"],"title":"220624","uri":"/220624/"},{"categories":["TIL"],"content":"Always I am improving developer!","date":"2022-06-21","objectID":"/220621/","tags":["copy_semantic","shallow_copy","exclusive_ownership_policy"],"title":"220621","uri":"/220621/"},{"categories":["TIL"],"content":" Copy semantics Udacity ","date":"2022-06-21","objectID":"/220621/:0:0","tags":["copy_semantic","shallow_copy","exclusive_ownership_policy"],"title":"220621","uri":"/220621/"},{"categories":["TIL"],"content":"Copy semantics 리소스 관리 (다중 스레드 락, 파일, 네트워크, 데이터베이스 연결 등) 리소스에 대한 엑세스는 종종 포인터로 다뤄짐 사용이 종료되면 해제해서 다른 사람이 재사용 할 수 있도록 해야 함 RAII (Resource Acquisition is Initialization, 자원 획득은 초기화) 멤버 변수 중 포인터가 있는 클래스의 경우 기본 복사 생성자가 복사할 때 포인터 변수에 대해서는 얕은 복사가 수행되서 문제가 발생할 수 있음 얕은 복사 : 변수의 위치만을 복사해옴 No copying policy : 가장 간단한 정책은 모든 클래스 인스턴스의 복사와 할당을 금지 복사 생성자를 private으로 만드는 것 NoCopyClass2(const NoCopyClass2 \u0026) = delete; Exclusive ownership policy : 객체에 대한 소유권은 하나만! 객체에 대한 복사를 수행하면 해당 객체가 소유한 포인터들의 소유권을 복사 된 객체로 옮겨줌 (복사 당한 객체에게는 nullptr ","date":"2022-06-21","objectID":"/220621/:1:0","tags":["copy_semantic","shallow_copy","exclusive_ownership_policy"],"title":"220621","uri":"/220621/"},{"categories":["TIL"],"content":"Always I am improving developer!","date":"2022-06-20","objectID":"/220620/","tags":["memory_management","malloc","free","new","delete"],"title":"220620","uri":"/220620/"},{"categories":["TIL"],"content":" Using malloc and free Using new and delete Typical memory management problems Udacity ","date":"2022-06-20","objectID":"/220620/:0:0","tags":["memory_management","malloc","free","new","delete"],"title":"220620","uri":"/220620/"},{"categories":["TIL"],"content":"Using malloc and free malloc 과 calloc은 모두 stdlib.h나 malloc.h에 포함된 함수 pointer_name = (cast-type*) malloc(size) : 하나의 거대한 메모리 블럭을 동적할당 해줌. malloc의 리턴값은 void*이기 때문에 원하는 타입으로 캐스팅 해줘야함 pointer_name = (cast-type*) calloc(num_elems, size_elem) : 여러개의 메모리 블럭을 동적할당 해줌. 모든 동적 할당된 메모리의 값은 0으로 초기화됨. malloc과 마찬가지로 void*로 출력 ","date":"2022-06-20","objectID":"/220620/:1:0","tags":["memory_management","malloc","free","new","delete"],"title":"220620","uri":"/220620/"},{"categories":["TIL"],"content":"Using new and delete malloc과 free는 C에 포함된 함수 new와 delete는 C++에서 소개된 연산자로서 객체지향에 대응 malloc으로 객체의 메모리 공간을 할당할 때, 생성자를 불러올 수 없음 (new는 가능) 소멸자에 대해서도 마찬가지로 free는 안되지만, delete는 가능함 placement new: void *memory = malloc(sizeof(MyClass)); MyClass *object = new (memory) MyClass; new (memory)문법이 placement new 원래 new와는 다른 점은 메모리 할당이 안됨 object-\u003e~MyClass(); free(memory); new와 delete는 연산자로 overloading이 가능함 void* operator new(size_t size); void operator delete(void*); ","date":"2022-06-20","objectID":"/220620/:2:0","tags":["memory_management","malloc","free","new","delete"],"title":"220620","uri":"/220620/"},{"categories":["TIL"],"content":"Typical memory management problems C++의 최고의 장점은 프로그래머가 직접 자원을 유연하게 제어 가능 메모리 유출(memory leaks): 런타임 도중 생성된 자원들을 적절히 해제해주지 않으면 발생 버퍼 오버런(buffer overrun): 할당된 메모리 공간보다 많은 자원을 사용하고자 하면 발생 char str[5]; strcpy(str, \"BufferOverrun\"); printf(\"%s\", str); 3. 초기화 되지 않은 메모리(uninitialized memory): 컴파일러에 따라 대부분은 0으로 메모리가 알아서 초기화 되지만, 메모리 할당 할 때 적절한 값으로 초기화 하지 않으면 발생 4. 부적절한 할당자-해제자 연결(incorrect pairing of allocation and deallocation): `malloc()` -\u003e `free()` : `new` -\u003e\u003e `delete` 5. 검증되지 않은 메모리 접근(invalid memory access): 이미 해제된 메모리에 접근하려 할 때 발생 ","date":"2022-06-20","objectID":"/220620/:3:0","tags":["memory_management","malloc","free","new","delete"],"title":"220620","uri":"/220620/"},{"categories":["TIL"],"content":"Always I am improving developer!","date":"2022-06-19","objectID":"/220619/","tags":["heap","memory_allocation"],"title":"220619","uri":"/220619/"},{"categories":["TIL"],"content":" Heap memory Using malloc and free Udacity ","date":"2022-06-19","objectID":"/220619/:0:0","tags":["heap","memory_allocation"],"title":"220619","uri":"/220619/"},{"categories":["TIL"],"content":"Heap memory 동적 할당에 사용되는 메모리 영역 BSS와 Data segment 바로 위에 위치해 있음 Stack은 높은 주소부터 낮은 주소로 확장되지만, Heap은 반대로 낮은 주소에서 높은 주소로 확장됨 Heap 메모리의 특징 Stack과 달리 scope를 벗어날 때 삭제되지 않고 남아있음 Stack은 컴파일 단계에서 결정되지만, heap은 런타임 단계에서 결정됨 Heap은 접근 가능한 메모리의 주소 공간의 크기에만 영향을 받음 (동적으로 할당된 변수를 해제 하는 것을 까먹으면, 메모리 누수라고 함) Stack과 달리 멀티 스래드상에서 공유될 수 있음 Stack은 할당/삭제가 순차적으로 이루어져 메모리 공간을 효율적으로 사용할 수 있지만, Heap의 경우에는 그러지 못해 관리가 까다로움 메모리 파편화 ","date":"2022-06-19","objectID":"/220619/:1:0","tags":["heap","memory_allocation"],"title":"220619","uri":"/220619/"},{"categories":["TIL"],"content":"Using malloc and free ","date":"2022-06-19","objectID":"/220619/:2:0","tags":["heap","memory_allocation"],"title":"220619","uri":"/220619/"},{"categories":["TIL"],"content":"Always I am improving developer!","date":"2022-06-18","objectID":"/220618/","tags":[],"title":"220618","uri":"/220618/"},{"categories":["TIL"],"content":"…Nothing.. ","date":"2022-06-18","objectID":"/220618/:0:0","tags":[],"title":"220618","uri":"/220618/"},{"categories":["TIL"],"content":"Always I am improving developer!","date":"2022-06-16","objectID":"/220616/","tags":["cmake","glob_recursive","google_engineer"],"title":"220616","uri":"/220616/"},{"categories":["TIL"],"content":" CMAKE 현재 폴더를 기준으로 하위 폴더를 포함한 모든 파일의 경로를 참조 구글 엔지니어는 이렇게 일한다 소프트웨어 엔지니어링이란 팀워크 이끌어 내기 CMAKE ","date":"2022-06-16","objectID":"/220616/:0:0","tags":["cmake","glob_recursive","google_engineer"],"title":"220616","uri":"/220616/"},{"categories":["TIL"],"content":"현재 폴더를 기준으로 하위 폴더를 포함한 모든 파일의 경로를 참조 FILE(GLOB_RECURSE SRC_FILES *.cpp) 현재 폴더를 기준으로 *.cpp의 패턴을 갖는 모든 파일의 경로를 SRC_FILES라는 이름으로 대체 구글 엔지니어는 이렇게 일한다 ","date":"2022-06-16","objectID":"/220616/:1:0","tags":["cmake","glob_recursive","google_engineer"],"title":"220616","uri":"/220616/"},{"categories":["TIL"],"content":"소프트웨어 엔지니어링이란 시간과 변경 규모 확장과 효율성 트레이드오프와 비용 소프트웨어 엔지니어링 vs 프로그래밍 ","date":"2022-06-16","objectID":"/220616/:2:0","tags":["cmake","glob_recursive","google_engineer"],"title":"220616","uri":"/220616/"},{"categories":["TIL"],"content":"팀워크 이끌어 내기 내 코드를 숨기고 싶어요 천재 신화 숨기는 건 해롭다 모든 건 팀에 달려 있다 ","date":"2022-06-16","objectID":"/220616/:3:0","tags":["cmake","glob_recursive","google_engineer"],"title":"220616","uri":"/220616/"},{"categories":["TIL"],"content":"Always I am improving developer!","date":"2022-06-14","objectID":"/220615/","tags":["hungarian_algorithm"],"title":"220615","uri":"/220615/"},{"categories":["TIL"],"content":"Hungarian Algorithm reference Step1 : 각 행(row)에서 가장 작은 원소로 해당 행의 요소를 모두 빼준다 Step2 : 각 열(column)에서 가장 작은 원소로 해당 열의 요소를 모두 빼준다 Step3 : 행렬에서 모든 0인 원소를 가능한 적은 행 그리고/또는 열을 마킹하여 덮어준다 Step4 : 왼쪽에 있는 원소로부터 가장 작은 원소를 찾는다. 마킹되지 않은 원소로 이것을 빼주고, 그것을 두개의 선으로 덮인 모든 원소들을 더해준다. 할당이 가능할 때 까지 step3-4를 반복한다. ","date":"2022-06-14","objectID":"/220615/:1:0","tags":["hungarian_algorithm"],"title":"220615","uri":"/220615/"},{"categories":["TIL"],"content":"Always I am improving developer!","date":"2022-06-11","objectID":"/220611/","tags":["vector_operation_==","matrix_multiplicity","clang_format"],"title":"220611","uri":"/220611/"},{"categories":["TIL"],"content":"C++ ","date":"2022-06-11","objectID":"/220611/:0:0","tags":["vector_operation_==","matrix_multiplicity","clang_format"],"title":"220611","uri":"/220611/"},{"categories":["TIL"],"content":"Vector Operator == bool operator==(const vector\u003cType, Allocator\u003e\u0026 left, const vector\u003cType, Allocator\u003e\u0026 right); left 와 right의 요소 수가 같고, 개별 요소가 같으면 true 아니면 false를 반환 ","date":"2022-06-11","objectID":"/220611/:1:0","tags":["vector_operation_==","matrix_multiplicity","clang_format"],"title":"220611","uri":"/220611/"},{"categories":["TIL"],"content":"Matrix multiplicity 행렬 곱 구현에 대한 방법들 비교 baseline으로 OpenCV matrix mult 사용 가장 일반적인 행렬곱 방법 메모리 효율을 높이기 위해 두번째 행렬을 transpose 시켜서 사용(메모리 캐싱에서 이득을 보기 위함) Debug 에서는 2x2 의 경우에는 3 \u003e 2 \u003e 1 (3번 방법이 가장 빠름) 10x10의 경우에는 1 \u003e 3 \u003e 2 (1번 방법이 가장 빠름) 100x100의 경우에는 1 \u003e 3 \u003e 2 (1번 방법이 가장 빠름) ","date":"2022-06-11","objectID":"/220611/:2:0","tags":["vector_operation_==","matrix_multiplicity","clang_format"],"title":"220611","uri":"/220611/"},{"categories":["TIL"],"content":"Clang-format clang-format src/*.cpp -i 위의 예시처럼 하면 특정 폴더 내의 cpp파일만 포메팅 가능 ","date":"2022-06-11","objectID":"/220611/:3:0","tags":["vector_operation_==","matrix_multiplicity","clang_format"],"title":"220611","uri":"/220611/"},{"categories":["TIL"],"content":"Always I am improving developer!","date":"2022-06-08","objectID":"/220608/","tags":["memory","cache_memory","virtual_memory"],"title":"220608","uri":"/220608/"},{"categories":["TIL"],"content":" Type of Computer Memory Cache Memory Virtual Memory Udacity ","date":"2022-06-08","objectID":"/220608/:0:0","tags":["memory","cache_memory","virtual_memory"],"title":"220608","uri":"/220608/"},{"categories":["TIL"],"content":"Type of Computer Memory Computer Memory Latency and Size Hierarchy CPU Cache L1, L2 RAM Physical RAM, Virtual Memory Permanent Storage Areas Removable Drives, Hard Dist, Network ","date":"2022-06-08","objectID":"/220608/:1:0","tags":["memory","cache_memory","virtual_memory"],"title":"220608","uri":"/220608/"},{"categories":["TIL"],"content":"Cache Memory Cache memory는 매우 빠르지만, 용량이 엄청 작음 (일반적인 RAM에 비해) RAM에 있는 정보를 바로 CPU로 이동시켜 연산하기엔 오버헤드가 크기 때문에 Cache를 활용함 Cache를 잘 활용하기 #include \u003cchrono\u003e#include \u003ciostream\u003e int main() { // create array const int size = 4; static int x[size][size]; auto t1 = std::chrono::high_resolution_clock::now(); for (int i = 0; i \u003c size; i++) { for (int j = 0; j \u003c size; j++) { x[j][i] = i + j; // 이중 배열 x에 접근하기 위한 접근자가 i가 바깥 for-loop, j가 안쪽 for-loop // x[j][i]에서 i 주변의 메모리를 캐싱하겠지만, 실제 반복되는 for-loop는 j // 이기 때문에 두개의 순서를 바꿔줌으로서 캐싱을 활용한 수행속도를 빠르게 할 //수 있다. std::cout \u003c\u003c \u0026x[j][i] \u003c\u003c \": i=\" \u003c\u003c i \u003c\u003c \", j=\" \u003c\u003c j \u003c\u003c std::endl; } } // print execution time to console auto t2 = std::chrono::high_resolution_clock::now(); // stop time measurement auto duration = std::chrono::duration_cast\u003cstd::chrono::microseconds\u003e(t2 - t1).count(); std::cout \u003c\u003c \"Execution time: \" \u003c\u003c duration \u003c\u003c \" microseconds\" \u003c\u003c std::endl; return 0; } ","date":"2022-06-08","objectID":"/220608/:2:0","tags":["memory","cache_memory","virtual_memory"],"title":"220608","uri":"/220608/"},{"categories":["TIL"],"content":"Virtual Memory Several memory-related problems: Holes in address space Programs writing over each other 메모리 관련 문제 해결에 가상 메모리가 큰 도움 32-bit 시스템은 32-bit의 주소 공간을 갖고 있음 -\u003e 사용 가능 최대 메모리 공간 $2^{32}$-bit = 4 GB ","date":"2022-06-08","objectID":"/220608/:3:0","tags":["memory","cache_memory","virtual_memory"],"title":"220608","uri":"/220608/"},{"categories":["TIL"],"content":"Always I am improving developer!","date":"2022-06-07","objectID":"/220607/","tags":["memory_address","hexadecimal"],"title":"220607","uri":"/220607/"},{"categories":["TIL"],"content":" 메모리 주소와 16진수 CppND-System-Monitor-Project (Review) Udacity ","date":"2022-06-07","objectID":"/220607/:0:0","tags":["memory_address","hexadecimal"],"title":"220607","uri":"/220607/"},{"categories":["TIL"],"content":"메모리 주소와 16진수 John Atanasoff가 두개의 숫자로 이루어진 부호화 시스템을 제안(‘부재’를 나타내는 숫자와 ‘존재’를 나타내는 두개의 숫자) 2진수 대신에 16진수를 사용하는 이유 가독성: 16진수가 2진수에 비해 10진법 표현에 가까워 가독성이 높음 정보 밀도: 0~255의 수를 표현하고자 할 때 16진수는 2개의 숫자만 있으면 되지만, 2진수는 8개가 필요함 byte로의 변환: 모든 컴퓨터는 byte로 표현된 주소를 사용하고 8개의 비트로 표현됨.(byte는 8bit) GDB (GNU DeBugger) ","date":"2022-06-07","objectID":"/220607/:1:0","tags":["memory_address","hexadecimal"],"title":"220607","uri":"/220607/"},{"categories":["TIL"],"content":"CppND-System-Monitor-Project (Review) 반복적인 코드를 최소화 하기 위해선 몇몇 일반적인 함수들을 정의해야 함 C++ Reference Material Style Convections Why we must close every opened file in C++ : 파일을 닫지 않아도 크게 문제될 것은 없지만 권장되지 않는 사항임 VmSize: Virtual memory size, VmRSS: exact physical memory Stackoverflow - Global variable “count” ambiguous 적절한 생성자가 있다면 벡터에 원소를 추가할 때 명시적으로 하지 않아도 됨 // 적절한 생성자 Process::Process (int pid) { _pid = pid; ...} // 다른 어딘가 vector\u003cProcess\u003e processes_ = {}; for (const int \u0026pid : pids) { processes_.emplace_back(pid); // processes_.emplace_back(Process(pid)); // 컴파일러가 알아서 적당한 생성자를 찾아줌(없으면 안되고..) } chrono librarry tutorial Make file과 연관된 몇몇 링크들 GNU MakeFile Documentation A Simple Makefile Tutorial Variable Name Convention 몇몇 하드 코딩된 변수들은 LinuxParser.h로 옮기는 것을 추천 ","date":"2022-06-07","objectID":"/220607/:2:0","tags":["memory_address","hexadecimal"],"title":"220607","uri":"/220607/"},{"categories":["TIL"],"content":"Always I am improving developer!","date":"2022-06-06","objectID":"/220606/","tags":["git","change_commit_date","sstream","iomanip","pad_digit","sysconf"],"title":"220606","uri":"/220606/"},{"categories":["TIL"],"content":"Git Git commit 날짜 바꾸기 Udacity ElapsedTime (seconds data convert HH:MM:SS) sysconf istringstream.good Memory Management Overview Git ","date":"2022-06-06","objectID":"/220606/:0:0","tags":["git","change_commit_date","sstream","iomanip","pad_digit","sysconf"],"title":"220606","uri":"/220606/"},{"categories":["TIL"],"content":"Git commit 날짜 바꾸기 git commit --amend --no-edit --date \"DD MM YYYY hh:mm:ss\" 특정 커밋에 대해 --amend는 이전 커밋 내용에 덮어쓰기의 의미 --no-edit은 현재 커밋 내용을 수정사항 없이 반영하겠다는 의미 --date는 날짜에 대한 옵션 Udacity ","date":"2022-06-06","objectID":"/220606/:1:0","tags":["git","change_commit_date","sstream","iomanip","pad_digit","sysconf"],"title":"220606","uri":"/220606/"},{"categories":["TIL"],"content":"ElapsedTime (seconds data convert HH:MM:SS) \u003ciomanip\u003e헤더 파일의 std::setfill('0')를 이용해 공백 자리를 0으로 채워넣고, std::setw(2)로 폭을 2로 설정해 놓음 \u003csstream\u003e 헤더 파일의 std::stringstream을 이용해 문자열의 처리를 \u003c\u003c 연산으로 해결 #include \u003csstream\u003e#include \u003ciomanip\u003e#include \u003cstring\u003e std::string foo(int32_t seconds){ int32_t second = seconds % 60; seconds /= 60; int32_t minute = seconds % 60; int32_t hour = seconds / 60; stringstream ss(\"\"); ss \u003c\u003c std::setfill('0') \u003c\u003c std::setw(2) \u003c\u003c hour \u003c\u003c \":\" \u003c\u003c minute \u003c\u003c \":\" \u003c\u003c second; return ss.str(); } ","date":"2022-06-06","objectID":"/220606/:2:0","tags":["git","change_commit_date","sstream","iomanip","pad_digit","sysconf"],"title":"220606","uri":"/220606/"},{"categories":["TIL"],"content":"sysconf sysconf 런타임에 대한 설정 정보 획득 reference sysconf(_SC_CLK_TCK) : 초당 클락(clock) 틱 수 정보를 얻음 ","date":"2022-06-06","objectID":"/220606/:3:0","tags":["git","change_commit_date","sstream","iomanip","pad_digit","sysconf"],"title":"220606","uri":"/220606/"},{"categories":["TIL"],"content":"istringstream.good good 스트림의 상태가 좋은지 확인 std::ios::good ","date":"2022-06-06","objectID":"/220606/:4:0","tags":["git","change_commit_date","sstream","iomanip","pad_digit","sysconf"],"title":"220606","uri":"/220606/"},{"categories":["TIL"],"content":"Memory Management Overview Overview of Memory Types Variables and Memory Dynamic Memory Allocation Resource Copying Policies Smart Pointers Project: Memory Management Chatbot ","date":"2022-06-06","objectID":"/220606/:5:0","tags":["git","change_commit_date","sstream","iomanip","pad_digit","sysconf"],"title":"220606","uri":"/220606/"},{"categories":["TIL"],"content":"Always I am improving developer!","date":"2022-06-05","objectID":"/220605/","tags":["memory_utilization"],"title":"220605","uri":"/220605/"},{"categories":["TIL"],"content":" Memory Utilization Udacity ","date":"2022-06-05","objectID":"/220605/:0:0","tags":["memory_utilization"],"title":"220605","uri":"/220605/"},{"categories":["TIL"],"content":"Memory Utilization Reference /proc 은 가상의 파일 시스템 /proc/meminfo는 비어있거나 사용중인 메모리의 양을 보고하기 위한 곳 cat /proc/meminfo를 통해 획득한 정보들은 상위와 하위 통계 형태로 제공 Stack-over-flow (mem usage from meminfo like htop) memory utilization은 MemTotal에서 MemFree + MemBuffers + Shmem + SReclaimable 의 총 합을 뺀 것(?) ","date":"2022-06-05","objectID":"/220605/:1:0","tags":["memory_utilization"],"title":"220605","uri":"/220605/"},{"categories":["TIL"],"content":"Always I am improving developer!","date":"2022-06-04","objectID":"/220604/","tags":["linux_system_data","process_data","processor_data","system_data"],"title":"220604","uri":"/220604/"},{"categories":["TIL"],"content":" System Data Processor Data Process Data Udacity ","date":"2022-06-04","objectID":"/220604/:0:0","tags":["linux_system_data","process_data","processor_data","system_data"],"title":"220604","uri":"/220604/"},{"categories":["TIL"],"content":"System Data Linux 수 많은 시스템 데이터를 /proc 디렉터리에 파일로 저장해두고 있음 Operating System : cat /etc/os-release Kernel : cat /proc/version Memory Utilization : cat /proc/meminfo Total Processes : cat /proc/stat Up Time : cat /proc/uptime ","date":"2022-06-04","objectID":"/220604/:1:0","tags":["linux_system_data","process_data","processor_data","system_data"],"title":"220604","uri":"/220604/"},{"categories":["TIL"],"content":"Processor Data Linux 는 프로세서 데이터를 proc/stat에 있는 파일에 저장 각 cpu에는 10개의 정수형 정보가 포함되어 있음 cpu0 6367 4 2360 4403129 9065 0 3972 0 0 0 first cpu는 각 cpuN의 총합이고 그 외 나머지는 각각의 cpu 소요 시간에 대한 정보 시간의 단위는 USER_HZ (보통은 hundredths of a second) 각 열의 의미는 아래와 같다(행의 왼쪽부터 오른쪽) user: normal processes executing in user mode nice: niced processes executing in user mode system: processes executing in kernel mode idle: twiddling thumbs iowait: In a word, iowait stands for waiting for I/O to complete. But there are several problems: Cpu will not wait for I/O to complete, iowait is the time that a task is waiting for I/O to complete. When cpu goes into idle state for outstanding task io, another task will be scheduled on this CPU. In a multi-core CPU, the task waiting for I/O to complete is not running on any CPU, so the iowait of each CPU is difficult to calculate. The value of iowait field in /proc/stat will decrease in certain conditions. So, the iowait is not reliable by reading from /proc/stat. irq: servicing interrupts softirq: servicing softirqs steal: involuntary wait guest: running a normal guest guest_nice: running a niced guest references : Guide, Stack-over-flow ","date":"2022-06-04","objectID":"/220604/:2:0","tags":["linux_system_data","process_data","processor_data","system_data"],"title":"220604","uri":"/220604/"},{"categories":["TIL"],"content":"Process Data PID (Process Identifier) UID (User Identifier) Username Processor Utilization Memory Utilization Up Time ","date":"2022-06-04","objectID":"/220604/:3:0","tags":["linux_system_data","process_data","processor_data","system_data"],"title":"220604","uri":"/220604/"},{"categories":[],"content":"Always I am improving developer!","date":"2022-06-03","objectID":"/220603/","tags":["deduction"],"title":"220603","uri":"/220603/"},{"categories":[],"content":" Deduction Exercise Class Template System Monitor Project! Style Code (C++) #Udacity ","date":"2022-06-03","objectID":"/220603/:0:0","tags":["deduction"],"title":"220603","uri":"/220603/"},{"categories":[],"content":"Deduction deduction Deduction은 객체를 생성할 때 타입을 명시하지 않으면 발생 예제 코드 #include \u003cassert.h\u003e // TODO: Declare a generic, templatized average function template\u003ctypename T\u003e T average(T a, T b) {return (a + b) * 0.5; } int main() { assert(average(2.0,5.0) == 3.5); } ","date":"2022-06-03","objectID":"/220603/:1:0","tags":["deduction"],"title":"220603","uri":"/220603/"},{"categories":[],"content":"Exercise Class Template #include \u003cassert.h\u003e#include \u003cstring\u003e#include \u003csstream\u003e // TODO: Add the correct template specification template\u003ctypename KeyType, typename ValueType\u003e class Mapping { public: Mapping(KeyType key, ValueType value) : key(key), value(value) {} std::string Print() const { std::ostringstream stream; stream \u003c\u003c key \u003c\u003c \": \" \u003c\u003c value; return stream.str(); } KeyType key; ValueType value; }; // Test int main() { Mapping\u003cstd::string, int\u003e mapping(\"age\", 20); assert(mapping.Print() == \"age: 20\"); } ","date":"2022-06-03","objectID":"/220603/:2:0","tags":["deduction"],"title":"220603","uri":"/220603/"},{"categories":[],"content":"System Monitor Project! htop - Linux system monitor ","date":"2022-06-03","objectID":"/220603/:3:0","tags":["deduction"],"title":"220603","uri":"/220603/"},{"categories":[],"content":"Style Code (C++) clang-format ","date":"2022-06-03","objectID":"/220603/:4:0","tags":["deduction"],"title":"220603","uri":"/220603/"},{"categories":["TIL"],"content":"Always I am improving developer!","date":"2022-06-02","objectID":"/220602/","tags":["multiple_inheritance","generic_programming","template"],"title":"220602","uri":"/220602/"},{"categories":["TIL"],"content":" Generic Programming Multiple Inheritance Udacity ","date":"2022-06-02","objectID":"/220602/:0:0","tags":["multiple_inheritance","generic_programming","template"],"title":"220602","uri":"/220602/"},{"categories":["TIL"],"content":"Multiple Inheritance “Use multiple inheritance to represent multiple distinct interfaces” “Use multiple inheritance to represent the union of implementation attributes” Diamond Problem : 하나의 클래스가 두개의 base class로 부터 상속받고, 이 두개의 base class들은 동일한 추상 클래스로부터 상속을 받았다면, 충돌이 생긴다. e.g. class Vehicle { public: virtual string Move() const = 0; }; class Boat : public Vehicle{ string Move() const; }; class Car : public Vehicle { string Move() const; }; class AmphibiousCar : public Boat, public Car{ }; int main(){ AmphibiousCar ab_car; ab_car.move(); // Which is inherited? return 0; } ","date":"2022-06-02","objectID":"/220602/:1:0","tags":["multiple_inheritance","generic_programming","template"],"title":"220602","uri":"/220602/"},{"categories":["TIL"],"content":"Generic Programming template을 사용하여 다양한 타입에 대응할 수 있도록 만드는 것을 generic programming 대표적으로 STL의 vector ","date":"2022-06-02","objectID":"/220602/:2:0","tags":["multiple_inheritance","generic_programming","template"],"title":"220602","uri":"/220602/"},{"categories":["TIL"],"content":"Template template 은 타입을 파라미터처럼 사용하여 다양한 데이터 타입에 대한 연산을 하나로 구현할 수 있음 template \u003ctypename Type\u003e Type Sum(Type a, Type b) {return a + b;} 실습 #include \u003cassert.h\u003e // TODO: Create a generic function Product that multiplies two parameters template\u003ctypename T\u003e T Product(T a, T b) {return a * b;} int main() { assert(Product\u003cint\u003e(10, 2) == 20); } 예제 : 비교 연산자 #include \u003cassert.h\u003e // TODO: Declare a generic, templatized function Max() template\u003ctypename T\u003e T Max(T a, T b) {return a \u003e b ? a : b;} int main() { assert(Max(10, 50) == 50); assert(Max(5.7, 1.436246) == 5.7); } ","date":"2022-06-02","objectID":"/220602/:2:1","tags":["multiple_inheritance","generic_programming","template"],"title":"220602","uri":"/220602/"},{"categories":["TIL"],"content":"Always I am improving developer!","date":"2022-06-01","objectID":"/220601/","tags":["operator_overloading","virtual_function","overriding","udacity"],"title":"220601","uri":"/220601/"},{"categories":["TIL"],"content":" Polymorphism: overloading (review) Polymorphism: operator Virtual Functions Overriding Polymorphism: operator Virtual Functions Overriding ","date":"2022-06-01","objectID":"/220601/:0:0","tags":["operator_overloading","virtual_function","overriding","udacity"],"title":"220601","uri":"/220601/"},{"categories":["TIL"],"content":"Polymorphism: overloading (review) 이전 강의에서 마저 듣지 못했던 나머지 내용 (코드 실습) #include \u003ciostream\u003e class Human {}; class Animal {}; class Dog {}; // TODO: Write hello() function void hello() { std::cout \u003c\u003c \"Hello, World!\\n\"; } // TODO: Overload hello() three times void hello(Human human) { std::cout \u003c\u003c \"Hello, Human!\\n\"; } void hello(Animal animal) { std::cout \u003c\u003c \"Hello, Animal!\\n\"; } void hello(Dog dog) { std::cout \u003c\u003c \"Hello, Dog!\\n\"; } // TODO: Call hello() from main() int main() { hello(); hello(Human()); hello(Animal()); hello(Dog()); } ","date":"2022-06-01","objectID":"/220601/:1:0","tags":["operator_overloading","virtual_function","overriding","udacity"],"title":"220601","uri":"/220601/"},{"categories":["TIL"],"content":"Polymorphism: operator ASCII table에 정의된 연산자를 선택해 새로운 연산 집합의 규칙을 정할 수 있음 // Example of '*'(plus) operator overloading! Complex operator+(const Complex\u0026 addend) { //...logic to add complex numbers } operator overloading, \u003c+,-,/,*\u003e + \u003c++, –, +=, -=, *=, /=\u003e, \u003c==, \u003c,\u003e,\u003c=,\u003e=,!=\u003e, … 등등 실습 코드 #include \u003cassert.h\u003e class Point { public: Point(int x, int y) : x(x), y(y){} int x; int y; Point operator+(const Point\u0026 p2){ return Point(x+p2.x, y+p2.y);} }; int main() { Point p1(10, 5), p2(2, 4); Point p3 = p1 + p2; // An example call to \"operator +\"; assert(p3.x == p1.x + p2.x); assert(p3.y == p1.y + p2.y); } ","date":"2022-06-01","objectID":"/220601/:2:0","tags":["operator_overloading","virtual_function","overriding","udacity"],"title":"220601","uri":"/220601/"},{"categories":["TIL"],"content":"Virtual Functions virtual return_t foo(input_t vars); virtual function은 다형성을 위한 특징 virtual function은 인터페이스를 위해 사용됨 pure virtual function virtual return_t foo(input_t vars); = 0 class Animal { virtual void Talk() const = 0; }; virtual function이 있는 클래스를 상속 받으면 해당 virtual function을 구현해야 함 virtual function이 있는 클래스는 인스턴스를 만들 수 없음 실습 코드 // Example solution for Shape inheritance #include \u003cassert.h\u003e#include \u003ccmath\u003e // TODO: Define pi const double pi = 3.14159; // TODO: Define the abstract class Shape class Shape{ // TODO: Define public virtual functions Area() and Perimeter() // TODO: Append the declarations with = 0 to specify pure virtual functions public: virtual double Area(void) const = 0; virtual double Perimeter(void) const = 0; }; class Rectangle : public Shape{ public: Rectangle(int width, int height) : width(width), height(height) {}; double Area(void) const { return width * height; } double Perimeter(void) const { return 2 * (width + height); } private: int width; int height; }; class Circle : public Shape { public: Circle(int radius) : radius(radius) {}; double Area(void) const { return radius * radius * pi; } double Perimeter(void) const { return 2 * pi * radius; } private: int radius; }; // Test in main() int main() { double epsilon = 0.1; // useful for floating point equality // Test circle Circle circle(12.31); assert(abs(circle.Perimeter() - 77.35) \u003c epsilon); assert(abs(circle.Area() - 476.06) \u003c epsilon); // Test rectangle Rectangle rectangle(10, 6); assert(rectangle.Perimeter() == 32); assert(rectangle.Area() == 60); } ","date":"2022-06-01","objectID":"/220601/:3:0","tags":["operator_overloading","virtual_function","overriding","udacity"],"title":"220601","uri":"/220601/"},{"categories":["TIL"],"content":"Overriding ","date":"2022-06-01","objectID":"/220601/:4:0","tags":["operator_overloading","virtual_function","overriding","udacity"],"title":"220601","uri":"/220601/"},{"categories":["TIL"],"content":"Concept of overriding overriding은 base class가 virtual함수로 정의 되었을 때 발생 derived class가 virtual 함수가 갖고 있던 입/출력 파라미터로 정의 예시 class Animal { public: virtual std::striing Talk() const = 0; }; class Cat{ public: std::string Talk() const { return std::string(\"Meow\"); } }; 실습 #include \u003cassert.h\u003e#include \u003cstring\u003e class Animal { public: virtual std::string Talk() const = 0; }; // TODO: Declare a class Dog that inherits from Animal class Dog { public: std::string Talk() { return \"Woof\"; } }; int main() { Dog dog; assert(dog.Talk() == \"Woof\"); } ","date":"2022-06-01","objectID":"/220601/:4:1","tags":["operator_overloading","virtual_function","overriding","udacity"],"title":"220601","uri":"/220601/"},{"categories":["TIL"],"content":"Function hiding function hiding 은 overriding과 유사하지만, 구분되는 특징이 있음 base class의 함수가 virtual로 정의 되지 않는다면 derived class 는 base class 의 함수를 숨김(hide) 예시 class Cat { // Here, Cat does not derive from a base class public: std::string Talk() const { return std::string(\"Meow\"); } }; class Lion : public Cat { public: std::string Talk() const { return std::string(\"Roar\"); } }; ","date":"2022-06-01","objectID":"/220601/:4:2","tags":["operator_overloading","virtual_function","overriding","udacity"],"title":"220601","uri":"/220601/"},{"categories":["TIL"],"content":"Override keyword overriding은 derived class가 상속 받은 virtual함수를 구현하였을 때 발생 override 키워드를 통해 지정할 수 있지만, 필수적이진 않음 이 키워드를 사용할 때, overriding 되지 않으면 에러가 발생함 예시 코드 class Shape { public: virtual double Area() const = 0; virtual double Perimeter() const = 0; }; class Circle : public Shape { public: Circle(double radius) : radius_(radius) {} double Area() const override { return pow(radius_, 2) * PI; } // specified as an override function double Perimeter() const override { return 2 * radius_ * PI; } // specified as an override function private: double radius_; }; 실습 코드 #include \u003cassert.h\u003e#include \u003ccmath\u003e // TODO: Define PI const double PI = 3.14159; // TODO: Declare abstract class VehicleModel class VehicleModel { // TODO: Declare virtual function Move() public: virtual void Move(double v, double theta) = 0; }; // TODO: Derive class ParticleModel from VehicleModel class ParticleModel : public VehicleModel { // TODO: Override the Move() function // TODO: Define x, y, and theta public: void Move(double v, double phi) { theta += phi; x += v * cos(theta); y += v * sin(theta); } double x, y, theta; }; // TODO: Derive class BicycleModel from ParticleModel class BicycleModel : public ParticleModel { public: void Move(double v, double phi) { theta += v / L * tan(phi); x += v * cos(theta); y += v * sin(theta); } double L; }; // TODO: Pass the tests int main() { // Test function overriding ParticleModel particle; BicycleModel bicycle; particle.Move(10, PI / 9); bicycle.Move(10, PI / 9); assert(particle.x != bicycle.x); assert(particle.y != bicycle.y); assert(particle.theta != bicycle.theta); } ","date":"2022-06-01","objectID":"/220601/:4:3","tags":["operator_overloading","virtual_function","overriding","udacity"],"title":"220601","uri":"/220601/"},{"categories":["TIL"],"content":"Always I am improving developer!","date":"2022-05-31","objectID":"/220531/","tags":["friend","polymorphism","overloading","udacity"],"title":"220531","uri":"/220531/"},{"categories":["TIL"],"content":" Polymorphism Friend ","date":"2022-05-31","objectID":"/220531/:0:0","tags":["friend","polymorphism","overloading","udacity"],"title":"220531","uri":"/220531/"},{"categories":["TIL"],"content":"Friend friend 클래스는 상속의 대안 일반적인 상속과 달리 private 멤버에도 접근 가능 class Heart { private: int rate{80}; friend class Human; } class Human { public: Heart heart; void Exercise(){ heart.rate = 150;} void HeartRate(){return heart.rate;} }; ","date":"2022-05-31","objectID":"/220531/:1:0","tags":["friend","polymorphism","overloading","udacity"],"title":"220531","uri":"/220531/"},{"categories":["TIL"],"content":"Polymorphism 다형성(polymorphism)은 “수 많은 형태를 가정\"했다는 의미 다형성은 C++상에서 두가지 방법으로 구현: overloading \u0026 overriding Overloading 두가지 이상의 이름만 같고 다른 버전의 함수를 구현하는 것을 일컫음 이름만 같고 입력 인수는 다양한 함수들! ","date":"2022-05-31","objectID":"/220531/:2:0","tags":["friend","polymorphism","overloading","udacity"],"title":"220531","uri":"/220531/"},{"categories":["TIL"],"content":"Always I am improving developer!","date":"2022-05-30","objectID":"/220530/","tags":["inheritance","access-specifier","composition","udacity"],"title":"220530","uri":"/220530/"},{"categories":["TIL"],"content":" Inheritance Access specifier Composition ","date":"2022-05-30","objectID":"/220530/:0:0","tags":["inheritance","access-specifier","composition","udacity"],"title":"220530","uri":"/220530/"},{"categories":["TIL"],"content":"Inheritance “Is a” 객체 지향의 토대가 되는 상속(inheritance) 상위 객체의 메소드와 변수 등을 상속 받은 하위 객체가 사용 가능 하위 객체는 상위 객체에 없는 메소드와 변수 등을 추가로 정의해 좀 더 구체적인 구현체를 만들 수 있음 상위 객체는 하위 객체들을 추상화 한 구현체 접근자(access specifier)를 통해 멤버 변수나 멤버 메소드에 접근을 제한하여 캡슐화(encapsulation) ","date":"2022-05-30","objectID":"/220530/:1:0","tags":["inheritance","access-specifier","composition","udacity"],"title":"220530","uri":"/220530/"},{"categories":["TIL"],"content":"Access specifier 상속 받을 때 접근자를 통해 상위 객체의 멤버 변수나 멤버 메소드에 접근을 제한할 수 있음 Public: 상속 받은 상위 객체의 public or protected 멤버 변수 및 멤버 메소드에 하위 객체가 접근 가능 Protect: 상속 받은 상위 객체의 public or protected 멤버 변수 및 멤버 메소드에 하위 객체의 protected 멤버로 접근자가 정해짐 Private: 상속 받은 상위 객체의 public or protected 멤버 변수 및 멤버 메소드에 하위 객체의 private 멤버로 접근자가 정해짐 ","date":"2022-05-30","objectID":"/220530/:2:0","tags":["inheritance","access-specifier","composition","udacity"],"title":"220530","uri":"/220530/"},{"categories":["TIL"],"content":"Composition “Has a” 상속을 받는 것이 아닌 다른 객체를 멤버로 받아 오는 것 ","date":"2022-05-30","objectID":"/220530/:3:0","tags":["inheritance","access-specifier","composition","udacity"],"title":"220530","uri":"/220530/"}]